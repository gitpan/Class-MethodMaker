IN NO GIVEN ORDER, Requests & Ideas

------------------------------------

new, init etc. to do SUPER-> as necessary

------------------------------------

Ability to proxy *all* unknown methods to attribute objects (in some
order..., using _can_)
 
------------------------------------
 
Use Damian Conway's "Switch" package...
 
-----------------------------------

object should be able to non auto-create, or auto-create with different
new method, and or with args (possibly generated by a subr)

------------------------------------

Ability to lock on a component.

------------------------------------

All list methods should check for definedness of field.  clear should
only clear if it needs it; should preserve existing ref?

------------------------------------

object should warn/error when given an object of the wrong type
(non-descendent.)

------------------------------------

Add stacks, queues, sets, other data structures.

------------------------------------

Add a list->slice method, that takes indexes, and returns (surprise!)  a
slice.

------------------------------------

REQUEST Make list->x replace the elements of list, rather than push (use
an argument to do this for now, later make it te default).

Frank Tobin sent a patch for this.

------------------------------------

IDEA
Add empty_copy method.
Add copy_into method.

------------------------------------

REQUEST
Add test for copy method to every normal test.

------------------------------------

REQUEST
Add general options parsing mechanism, for use of meta-methods.

------------------------------------

REQUEST
Add methods for defined / exists / delete on get_set.

------------------------------------

REQUEST
Add hash each method, probably using a closure to provide iteration.
Alternatively, save the keys, check each one before returning.

------------------------------------

REQUEST
The docs have to be re-organized. The order should be something like:

  new
  new_with_init
  hash_init
  get_set
  static_get_set
  list
  static_hash
  boolean
  object
  code

------------------------------------

IDEA
Maybe once there is a static implementation for each type (list,
hash, get_set), the static-ness should be set with a keyword and not a
partiuclar value:

  use Class::MethodMaker
    get_set => [qw/ foo -static bar /];

Alternative possible syntax for options:

  use Class::MethodMaker
    get_set => [qw/ foo bar(static) /];
Applies static option to bar only.

------------------------------------

REQUEST

Add constraints/bounds (a la Java Beans) to get_set (and others?), also
pre-post get/set methods

------------------------------------

IDEA
Add support for tied arrays & scalars, a la tie_hash

------------------------------------

IDEA
Add filehandle method.  Is get_set insufficient?

------------------------------------

IDEA
Add (nested) grouping functionality directly to get_set.

------------------------------------

REQUEST
Use Pseudohashes --- make it a class option, for compatibility.

------------------------------------

REQUEST
Synchronize static_hash with hash

------------------------------------

REQUEST
Add new-style list methods (i.e., x_verb)
Check for any methods generated that are not
preceded with slot name.

Make list methods consistent with hash_of_lists methods, in action, and
in name (x_verb).  Also for others (e.g., set_ clear_ boolean)

------------------------------------

REQUEST
Add int type.
Should this be an instance of a more generic checkable-type get_set?
If so, how does this fit in with constrained get_sets?

------------------------------------

IDEA
Add callback possibility into procedures? Maybe use ties?
How does this fit in with bound/constrained get_sets?

------------------------------------

REQUEST
Deprecate verb_x methods

------------------------------------

REQUEST
Add object exists method (non-auto-create ?)

------------------------------------

REQUEST
Add ability to not auto-create value of object method.

------------------------------------

REQUEST
Add renaming forwarding (i.e., forward x->foo as x->y->bar) and arg
reordering (i.e., x->foo (a,b,c) as x->y->bar (b,a))

------------------------------------

IDEA
Prefix internal names with '__' ?

------------------------------------

IDEA
Is struct still useful ?

------------------------------------

REQUEST
Add memoizing values (scalar, list, etc.)

------------------------------------

IDEA
Autoexpansion of array refs in list basic method is a gotcha if you're
trying to insert arrayrefs into the list

------------------------------------

IDEA
It would be good to create new_... methods which accepted prototype
objects to clone with Ref::copyref, which enables nice defaults
management and allows use with non-hash-based classes.

------------------------------------

IDEA
builtin_class:
Add -fatal flag to die if core func returns false / undef
Add call method to recall method with alternative arguments.
Add -nocall flag to not call core func on new.

------------------------------------